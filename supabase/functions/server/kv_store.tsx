/* AUTOGENERATED FILE - DO NOT EDIT CONTENTS */

/* Table schema:
CREATE TABLE kv_store_0f597298 (
  key TEXT NOT NULL PRIMARY KEY,
  value JSONB NOT NULL
);
*/

// View at https://supabase.com/dashboard/project/qcvlycewqdhrhoehkcpa/database/tables

// This file provides a simple key-value interface for storing Figma Make data. It should be adequate for most small-scale use cases.
import { createClient } from "jsr:@supabase/supabase-js@2.49.8";

export class KvStoreError extends Error {
  code?: string;

  constructor(message: string, code?: string) {
    super(message);
    this.name = "KvStoreError";
    this.code = code;
  }
}

type RpcError = {
  message: string;
  code?: string;
  details?: string | null;
  hint?: string | null;
};

const toKvError = (error: RpcError): KvStoreError =>
  new KvStoreError(error.message, error.code ?? undefined);

const client = () => createClient(
  Deno.env.get("SUPABASE_URL"),
  Deno.env.get("SUPABASE_SERVICE_ROLE_KEY"),
);

// Set stores a key-value pair in the database.
export const set = async (key: string, value: any): Promise<void> => {
  const supabase = client()
  const { error } = await supabase.from("kv_store_0f597298").upsert({
    key,
    value
  });
  if (error) {
    throw new Error(error.message);
  }
};

const normalizeUserValue = <T = unknown>(value: T | string): T => {
  if (typeof value === "string") {
    try {
      return JSON.parse(value);
    } catch {
      // fall through
    }
  }
  return value as T;
};

interface IncrementParams {
  userKey: string;
  energyDelta: number;
  lastWatchAt: string;
  watchCountKey: string;
  watchIncrement: number;
  dailyLimit: number;
  adId: string;
  baseReward: number;
  multiplier: number;
  countryCode?: string | null;
}

interface IncrementResult<TUser = any> {
  user: TUser;
  watch_count: number;
}

export const incrementUserEnergyAndWatchCount = async <TUser = any>(
  params: IncrementParams,
): Promise<IncrementResult<TUser>> => {
  const supabase = client();
  const { data, error } = await supabase.rpc(
    "increment_user_energy_and_watch_count",
    {
      user_key: params.userKey,
      energy_delta: params.energyDelta,
      last_watch_at: params.lastWatchAt,
      watch_count_key: params.watchCountKey,
      watch_increment: params.watchIncrement,
      daily_limit: params.dailyLimit,
      watch_ad_id: params.adId,
      watch_base_reward: params.baseReward,
      watch_multiplier: params.multiplier,
      watch_country_code: params.countryCode ?? null,
    },
  );

  if (error) {
    throw toKvError(error as RpcError);
  }

  const result = (data ?? {}) as { user?: unknown; watch_count?: number };

  return {
    user: normalizeUserValue<TUser>(result.user ?? ({} as TUser)),
    watch_count: Number(result.watch_count ?? 0),
  };
};

interface ClaimRewardParams<TClaim = any> {
  userKey: string;
  energyDelta: number;
  claimKey: string;
  claimValue: TClaim;
}

interface ClaimRewardResult<TUser = any> {
  user: TUser;
}

export const claimPartnerRewardAtomic = async <TUser = any, TClaim = any>(
  params: ClaimRewardParams<TClaim>,
): Promise<ClaimRewardResult<TUser>> => {
  const supabase = client();
  const { data, error } = await supabase.rpc("claim_partner_reward", {
    user_key: params.userKey,
    energy_delta: params.energyDelta,
    claim_key: params.claimKey,
    claim_value: params.claimValue,
  });

  if (error) {
    throw toKvError(error as RpcError);
  }

  const result = (data ?? {}) as { user?: unknown };

  return {
    user: normalizeUserValue<TUser>(result.user ?? ({} as TUser)),
  };
};

// Get retrieves a key-value pair from the database.
export const get = async (key: string): Promise<any> => {
  const supabase = client()
  const { data, error } = await supabase.from("kv_store_0f597298").select("value").eq("key", key).maybeSingle();
  if (error) {
    throw new Error(error.message);
  }
  return data?.value;
};

// Delete deletes a key-value pair from the database.
export const del = async (key: string): Promise<void> => {
  const supabase = client()
  const { error } = await supabase.from("kv_store_0f597298").delete().eq("key", key);
  if (error) {
    throw new Error(error.message);
  }
};

// Sets multiple key-value pairs in the database.
export const mset = async (keys: string[], values: any[]): Promise<void> => {
  const supabase = client()
  const { error } = await supabase.from("kv_store_0f597298").upsert(keys.map((k, i) => ({ key: k, value: values[i] })));
  if (error) {
    throw new Error(error.message);
  }
};

// Gets multiple key-value pairs from the database.
export const mget = async (keys: string[]): Promise<any[]> => {
  const supabase = client()
  const { data, error } = await supabase.from("kv_store_0f597298").select("value").in("key", keys);
  if (error) {
    throw new Error(error.message);
  }
  return data?.map((d) => d.value) ?? [];
};

// Deletes multiple key-value pairs from the database.
export const mdel = async (keys: string[]): Promise<void> => {
  const supabase = client()
  const { error } = await supabase.from("kv_store_0f597298").delete().in("key", keys);
  if (error) {
    throw new Error(error.message);
  }
};

// Search for key-value pairs by prefix.
export const getByPrefix = async (prefix: string): Promise<any[]> => {
  const supabase = client()
  const { data, error } = await supabase.from("kv_store_0f597298").select("key, value").like("key", prefix + "%");
  if (error) {
    throw new Error(error.message);
  }
  return data?.map((d) => d.value) ?? [];
};